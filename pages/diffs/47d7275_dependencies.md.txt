diff --git a/docs/build/dependencies.md b/docs/build/dependencies.md
index 44c8579..bd8e74c 100644
--- a/docs/build/dependencies.md
+++ b/docs/build/dependencies.md
@@ -4,7 +4,8 @@ url: https://developer.android.com/build/dependencies
 source: md.txt
 ---
 
-| **Note:** When adding dependencies, consider enabling [Dependency verification](https://developer.android.com/build/dependency-verification) to help ensure the dependencies you download and include in your project are what you expect.
+> [!NOTE]
+> **Note:** When adding dependencies, consider enabling [Dependency verification](https://developer.android.com/build/dependency-verification) to help ensure the dependencies you download and include in your project are what you expect.
 
 The Gradle build system in Android Studio lets you include external binaries or
 other library modules to your build as dependencies. The dependencies can be
@@ -17,7 +18,9 @@ plugin (AGP). For a deeper conceptual guide to Gradle dependencies, see the
 management](https://docs.gradle.org/current/userguide/getting_started_dep_man.html),
 but remember that your Android project must use only the [dependency
 configurations](https://developer.android.com/build/dependencies#dependency_configurations) defined on this page.
-| **Caution:** When specifying dependencies, you should not use dynamic version numbers, such as `'com.android.tools.build:gradle:3.+'`. Using this feature can cause unexpected version updates, difficulty resolving version differences, and poor performance.
+
+> [!CAUTION]
+> **Caution:** When specifying dependencies, you should not use dynamic version numbers, such as `'com.android.tools.build:gradle:3.+'`. Using this feature can cause unexpected version updates, difficulty resolving version differences, and poor performance.
 
 ## Add a library or plugin dependency
 
@@ -40,8 +43,10 @@ library](https://developer.android.com/jetpack/androidx/releases/benchmark)), [l
 dependency](https://developer.android.com/studio/projects/android-library) (`myLibrary`), and a plugin
 dependency (the Android Gradle plugin) to our project. Here are the general
 steps to add these dependencies to your project:
-| **Note:** It's possible to [declare version catalogs in the settings
-| file](https://docs.gradle.org/current/userguide/platforms.html#sub:version-catalog-declaration), but we recommend using a separate `toml` file to get more support with code suggestions and highlighting from Android Studio.
+
+> [!NOTE]
+> **Note:** It's possible to [declare version catalogs in the settings
+> file](https://docs.gradle.org/current/userguide/platforms.html#sub:version-catalog-declaration), but we recommend using a separate `toml` file to get more support with code suggestions and highlighting from Android Studio.
 
 1. Add an alias for the version of the dependency that you want in the
    `[versions]` section of the version catalog file, called
@@ -139,7 +144,7 @@ of the configurations you can use for a dependency in your Android project.
 | `api` | Gradle adds the dependency to the compile classpath and build output. When a module includes an `api` dependency, it's letting Gradle know that the module wants to transitively export that dependency to other modules, so that it's available to them at both runtime and compile time. Use this configuration with caution and only with dependencies that you need to transitively export to other upstream consumers. If an `api` dependency changes its external API, Gradle recompiles all modules that have access to that dependency at compile time. Having a large number of `api` dependencies can significantly increase build time. Unless you want to expose a dependency's API to a separate module, library modules should instead use `implementation` dependencies. |
 | `compileOnly` | Gradle adds the dependency to the compile classpath only (that is, it's not added to the build output). This is useful when you're creating an Android module and you need the dependency during compilation, but it's optional to have it present at runtime. For example, if you depend on a library that only includes compile-time annotations---typically used to generate code but often not included in the build output---you could mark that library `compileOnly`. <br /> If you use this configuration, then your library module must include a runtime condition to check whether the dependency is available, and then gracefully change its behavior so it can still function if it's not provided. This helps reduce the size of the final app by not adding transient dependencies that aren't critical. **Note:** You can't use the `compileOnly` configuration with Android Archive (AAR) dependencies. |
 | `runtimeOnly` | Gradle adds the dependency to the build output only, for use during runtime. That is, it isn't added to the compile classpath. This is rarely used on Android, but commonly used in server applications to provide logging implementations. For example, a library could use a logging API that doesn't include an implementation. Consumers of that library could add it as an `implementation` dependency and include a `runtimeOnly` dependency for the actual logging implementation to use. |
-| `ksp` `kapt` `annotationProcessor` | These configurations supply libraries that process annotations and other symbols in your code before it is compiled. They typically validate your code or generate additional code, reducing the code you need to write. To add such a dependency, you must add it to the annotation processor classpath using the `ksp`, `kapt`, or `annotationProcessor` configurations. Using these configurations improves build performance by separating the compile classpath from the annotation processor classpath. If Gradle finds annotation processors on the compile classpath, it deactivates [compile avoidance](https://docs.gradle.org/current/userguide/java_plugin.html#sec:java_compile_avoidance), which negatively impacts build time (Gradle 5.0 and higher ignore annotation processors found on the compile classpath). The Android Gradle plugin assumes a dependency is an annotation processor if its JAR file contains the following file: `META-INF/services/javax.annotation.processing.Processor` If the plugin detects an annotation processor that's on the compile classpath, it produces a build error. `ksp` is a Kotlin Symbol Processor, and is run by the Kotlin compiler. `kapt` and `apt` are separate tools that process annotations before Kotlin or Java compilers execute. When deciding which configuration to use, consider the following: - If a processor is available as a Kotlin Symbol Processor, use it as a `ksp` dependency. See [Migrate from kapt to ksp](https://developer.android.com/build/migrate-to-ksp) for details on using Kotlin Symbol Processors. - If the processor isn't available as a Kotlin Symbol Processor: - If your project includes Kotlin source (but can also include Java source), [use `kapt`](https://kotlinlang.org/docs/reference/kapt.html) to include it. - If your project only uses Java source, use `annotationProcessor` to include it. For more information about using annotation processors, see [Add annotation processors](https://developer.android.com/build/annotation-processors). |
+| `ksp kapt annotationProcessor` | These configurations supply libraries that process annotations and other symbols in your code before it is compiled. They typically validate your code or generate additional code, reducing the code you need to write. To add such a dependency, you must add it to the annotation processor classpath using the `ksp`, `kapt`, or `annotationProcessor` configurations. Using these configurations improves build performance by separating the compile classpath from the annotation processor classpath. If Gradle finds annotation processors on the compile classpath, it deactivates [compile avoidance](https://docs.gradle.org/current/userguide/java_plugin.html#sec:java_compile_avoidance), which negatively impacts build time (Gradle 5.0 and higher ignore annotation processors found on the compile classpath). The Android Gradle plugin assumes a dependency is an annotation processor if its JAR file contains the following file: `META-INF/services/javax.annotation.processing.Processor` If the plugin detects an annotation processor that's on the compile classpath, it produces a build error. `ksp` is a Kotlin Symbol Processor, and is run by the Kotlin compiler. `kapt` and `apt` are separate tools that process annotations before Kotlin or Java compilers execute. When deciding which configuration to use, consider the following: - If a processor is available as a Kotlin Symbol Processor, use it as a `ksp` dependency. See [Migrate from kapt to ksp](https://developer.android.com/build/migrate-to-ksp) for details on using Kotlin Symbol Processors. - If the processor isn't available as a Kotlin Symbol Processor: - If your project includes Kotlin source (but can also include Java source), [use `kapt`](https://kotlinlang.org/docs/reference/kapt.html) to include it. - If your project only uses Java source, use `annotationProcessor` to include it. For more information about using annotation processors, see [Add annotation processors](https://developer.android.com/build/annotation-processors). |
 | `lintChecks` | Use this configuration to include a library containing lint checks you want Gradle to execute when building your Android app project. Note that AARs that contain a `lint.jar` file will automatically run checks defined in that `lint.jar` file; you don't need to add an explicit `lintChecks` dependency. This lets you define libraries and associated lint checks in a single dependency, ensuring that your checks are run when consumers use your library. |
 | `lintPublish` | Use this configuration in Android library projects to include lint checks you want Gradle to compile into a `lint.jar` file and package in your AAR. This causes projects that consume your AAR to also apply those lint checks. If you were previously using the `lintChecks` dependency configuration to include lint checks in the published AAR, you need to migrate those dependencies to instead use the `lintPublish` configuration. ### Kotlin ```kotlin dependencies { // Executes lint checks from the ":checks" project at build time. lintChecks(project(":checks")) // Compiles lint checks from the ":checks-to-publish" into a // lint.jar file and publishes it to your Android library. lintPublish(project(":checks-to-publish")) } ``` ### Groovy ```groovy dependencies { // Executes lint checks from the ':checks' project at build time. lintChecks project(':checks') // Compiles lint checks from the ':checks-to-publish' into a // lint.jar file and publishes it to your Android library. lintPublish project(':checks-to-publish') } ``` |
 
@@ -154,7 +159,7 @@ set](https://developer.android.com/studio/test#sourcesets), you must capitalize
 name and prefix it with the name of the build variant or testing source set.
 
 For example, to add a remote binary dependency only to your "free" product
-flavor using the `implementation` configuration, use this:  
+flavor using the `implementation` configuration, use this:
 
 ### Kotlin
 
@@ -173,7 +178,7 @@ dependencies {
 ```
 
 However, if you want to add a dependency for a variant that combines a product
-flavor and a build type, then you must initialize the configuration name:  
+flavor and a build type, then you must initialize the configuration name:
 
 ### Kotlin
 
@@ -200,7 +205,7 @@ dependencies {
 ```
 
 To add `implementation` dependencies for your local tests and instrumented tests
-, it looks like this:  
+, it looks like this:
 
 ### Kotlin
 
@@ -228,7 +233,7 @@ dependencies {
 
 However, certain configurations don't make sense in this situation. For example,
 because other modules can't depend on `androidTest`, you get the following
-warning if you use the `androidTestApi` configuration:  
+warning if you use the `androidTestApi` configuration:
 
 ```
 WARNING: Configuration 'androidTestApi' is obsolete and has been replaced with
@@ -279,7 +284,7 @@ the signing block of your release app. We recommend keeping this dependencies
 file for a safe and positive user experience. You can opt out by including the
 following
 [`dependenciesInfo`](https://developer.android.com/reference/tools/gradle-api/7.1/com/android/build/api/dsl/DependenciesInfo)
-block in your module's `build.gradle.kts` file.  
+block in your module's `build.gradle.kts` file.
 
     android {
         dependenciesInfo {
@@ -313,7 +318,7 @@ Console in the future.
 
 We recommend using version catalogs to add and manage dependencies, but simple
 projects might not need them. Here's an example of a build file that doesn't use
-version catalogs:  
+version catalogs:
 
 ### Kotlin
 
@@ -351,7 +356,7 @@ dependencies {
 
 This build file declares a dependency on version 12.3 of the "app-magic"
 library, inside the "com.example.android" namespace group. The remote binary
-dependency declaration is shorthand for the following:  
+dependency declaration is shorthand for the following:
 
 ### Kotlin
 
@@ -378,7 +383,7 @@ across all modules. Instead of specifying the version in each of the module
 build scripts, you should include the plugin dependency in the root build script
 with the version, and indicate to not apply it. Adding `apply false` tells
 Gradle to note the version of the plugin but not to use it in the root build.
-Typically the root build script is empty except for this `plugins` block.  
+Typically the root build script is empty except for this `plugins` block.
 
 ### Kotlin
 
@@ -397,7 +402,7 @@ plugins {
 ```
 
 If you have a single-module project you can specify the version explicitly in
-the module-level build script and leave the project-level build script empty:  
+the module-level build script and leave the project-level build script empty:
 
 ### Kotlin
 
